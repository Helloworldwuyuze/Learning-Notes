# Tarjan 算法

## 强联通分量 （SCC）

**强联通分量（SCC）**，表示图中一段能够两两互相到达的极大子图。

### DFS树

在使用 $DFS$ 遍历一张图时，会产生四种边：

- **树边（Tree Edge）**，表示在进行搜索时走过的边。
- **返祖边（Back Edge）**，表示在搜索到一个点时走到还在栈中的节点的边。
- **横边（Cross Edge）**，表示在一个节点到达另一个不在栈中的节点的边。
- **前向边（Forward Edge）**，表示在祖先到它的二三及更高级儿子的边。

### 补充

并且定义两个数组 $dfn_i$ 和 $low_i$，$dfn$ 即遍历到该节点的次序，而 $low_u$ 表示在 $u$ 点子树里的节点引出的所有边能到达的节点的 $dfn$ 的最小值。

- **定理1**，若在 $DFS$ 中遍历到一个强联通分块的第一个节点为 $u$，那么该强联通分块一定在 $u$ 的子树内。

> **证明**
>
> 假如强联通分块并不在 $u$ 的子树内，那么总存在一个节点满足 $x$ 是 $u$ 的祖先并且该点在该联通分块内，那么 $x$ 一定比 $u$ 更先遍历到，与假设不符，故原命题成立。

### 算法过程

根据 $dfn$ 和 $low$ 的定义，只要 ```low_u<dfn_u```，则该节点只通过自己的子树一定能回到自己的祖先，即它和它的祖先在一个强联通分块内，它并不是强联通分块最先遍历到的点。

进而，如果 ```dfn_u==low_u```，那么该节点就是一个新的强连通分块的起点，回溯栈存储该联通分块即可。

### 代码实现

```cpp
void Tarjan(int x,int fa){
	dfn[x]=++idx, low[x]=dfn[x];
	st[++top]=x; ins[x]=true;
	for(int y:g[x])
		if(!dfn[y])	Tarjan(y,x), low[x]=min(low[x],low[y]);
		else if(ins[y])	low[x]=min(low[x],dfn[y]);
	if(dfn[x]==low[x]){
		++cnt;
		do{
			y=st[top--]; belong[y]=cnt;
			sc[cnt].insert(y); ins[y]=false;
		}while(y!=x);
	}
}
```

## 边双连通分量（EDCC）

- **定义** 边双联通分量表示在图 $G=\{V,E\}$ 中一段任意删去一边都不影响该连通性的极大子图。也就是图 $G=\{V,E\}$ 中不含桥的极大子图。
- **桥** 一条边是桥当且仅当删去该边后连通性发生变化。

我们仍然使用 ```dfn``` 和 ```low``` 两个数组，显然，对于边 $(u,v)$，若 ```low_v>dfn_u``` 那么该边一定为桥。

## 点双联通分量（PDCC）

- **割点** 如果一个将一个点删去后整张图的连通性发生了变化，那么称该点为割点。
- **定义** 一张图中不含割点的极大联通块即为点双连通分量（PDCC）

这里判定与桥唯一的不同在于 ```low_v>=dfn_u``` 而非严格大于，因为就算回到该点也不影响它的割点的性质。另外在根节点要判断它的儿子数量，若儿子数量大于2，则显然它是割点。
